function foo() {
  var name = 'foo'
  function bar() {
    console.log('bar', name)
  }

  return bar
}

var fn = foo()
fn()

var name = 'wyatt'
function test1() {
  console.log(name)
  // 上層作用域是在解析的時候就確認過了，與定義的位置有關，不是調用的位置
}
function test2() {
  var name = 'test2'
  test1()
}

// 閉包是兩部分組成的: 函數+可以訪問的自由變量

// 閉包和函數的區別在於捕捉閉包的時候，當捕捉閉包的時候，他的自由變量會在捕捉時被確定，即便脫離了上下文，也能照常運行。

// 閉包在實現上是一個結構體，他儲存了一個函數和一個關聯的環境(相當於一個符號查找表)

// 支持頭等函數的程式語言中。實現詞法綁定的一個技術。

// 也就是說就是一個函數和其周圍狀態(詞法環境, lexical environment)的引用綑綁在一起(或者說函數被引用包圍)，這就是閉包。

// 閉包創建時機是在函數創建時就同時被創建出來

// 閉包可以讓你在內層的函數訪問到外層函數的作用域。

// 一個普通的函數function，如果他可以訪問的外層作用域的自由變量，那麼這個函數就是一個閉包

// 廣義角度來說: Javascript的函數都是閉包
// 狹義角度來說: Javascript中一個函數，如果訪問了外層作用域的變量，那麼他就是閉包
